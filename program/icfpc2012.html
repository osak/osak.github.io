<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="../style_memoyoushi.css" />




<title>メモ用紙2.0 | ICFPC2012参加記</title>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-K7GK6FJ729"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-K7GK6FJ729');
</script>

</head>
<body>
<div id="header">
  <h1 class="title"><a href="../index_memoyoushi.html">メモ用紙2.0</a></h1>
  <address>osak.63 at_mark gmail.com</address>
</div>
<div id="body">
  <div id="menu">
    <ul>
      <li><a href="../about.html">About</a></li>
      <li><a href="index.html">Program</a></li>
      <li><a href="../linux/index.html">Linux</a></li>
      <li><a href="../hardware/index.html">Hardware</a></li>
      <li><a href="../trip/index.html">Trip</a></li>
      <li><a href="../food/index.html">Food</a></li>
      <li><a href="../other/index.html">Other</a></li>
      <li><a href="../diary/index.html">Diary</a></li>
    </ul>
  </div>

  <div id="main">
    <h2 id="icfpc2012">ICFPC2012参加記</h2>

<p>チームW88FでICFPC2012に参加しました．
チーム名は東工大の西8号館8階に集まってやってたから．</p>

<p>メンバーは自分と@Mi_Sawa，@tokoharu_sakura，@wand125，@eagletmt，@draftcode，@choro3，ymzk．
当初はwand家でやる予定だったけど，ゼミ室が使えることになったのと人数が多いのとで学内開催になりました．</p>

<p>以下，だいたい時系列の記録．
自分以外の人が何やってたかあまりちゃんと分かってないので，自分のやったことが中心です．</p>

<p>記録以外の感想は <a href="../diary/diary_201207.html#20120717">日記へ</a> ．</p>

<h3 id="section">初日</h3>

<p>20時くらいからgithubにリポジトリ用意したりして待機．
21時になって問題を読む． 今年の問題はLambda
Lifterという名前で，自分は聞いたことなかったけどその道では有名な概念らしい．
下向きに重力のかかっているフィールドを歩き回ってλを回収する．
地面を掘ってると岩が落ちてくることがあって，これに当たると死亡．</p>

<p>最初は死亡判定が鬼門だった．
自分の上のマスに岩が出現するような状態だと死，ということをWeb
Validatorにいろいろ入力食わせたり仕様書を読み返したりして納得する作業をした．</p>

<p>で，1時間以上かけて仕様を把握．
よく見るとマップの大きさは最大で1000×1000とか書いてあってやばい感じが漂っている．
まあ最初から最大ケースを考えてても仕方がなく，この時点でできるのはAI考えるかシミュレータ書くか手作業で問題解くかなので，自分はRubyでシミュレータを書くことにした．
適当にガシガシ書いてそれっぽいものが完成．
その間に@eagletmtが反復深化でAIを作っていたようなので，じゃあこっちも書いてみようと思ってRubyで適当に実装．
一応書き上げたけどこれ以上の発展が思いつかないので方針を変えてA*っぽいものを実装したり，謎のヒューリスティック関数を作ったりしてた．</p>

<p>そんなことをやりつつWeb
Validatorをリロードしてみたらテストケースが突然増えててびびる．
なんか水位の概念ができて溺死するようになるらしい．
水中でHPが減るタイミングと死亡判定のタイミングが仕様書からはよく分からないので，実行委員の悪口を言いながらWeb
Validatorにいろいろ入力を投げて境界条件を洗い出し，@eagletmt，@draftcode，@Mi_Sawaと議論して処理フローを推測した．
条件さえ分かってしまえば実装は楽なのでさくっと実装． このへんで力尽きて
<a href="http://samuraicoding.org/rules/">SamurAI Codingのルール</a>
読んだり適当な探索アイデアを口走ったりしながら寝る(この時点で7時くらい)．</p>

<h3 id="section-1">2日目</h3>

<p>10時に起きて，A*のヒューリスティック考えながらシミュレータいじる．
この日は <a href="http://connpass.com/event/706/">#w8hack</a>
がゼミ室で開催されてたので流れで参加した(と言ってもICFPCやってるだけ)．
ヒューリスティック関数はパラメータいろいろいじっても一定以上良くならず，Beam
Searchにして状態数を減らしてもあまり改善しないのでシミュレータいじるほうが楽しくなってくる．
どうにかしてnethackみたいにコンソール上で打鍵に即座に反応して操作できるようにしたいなー，でもcurses使うとWindowsで動かないしなーと思って調べてたら，Rubyでも
<code>require 'io/console'</code> とするとWindowsの <code>getch()</code>
みたいなことができるようになるらしい．
これを使って手動でさくさく解くためのゲームモードを実装．</p>

<p>夕方ごろにICFPCのMLが一気に届いて，その中にパズルっぽい自作問題へのリンクがあったので遊んでみたり，@wand125の生成した迷路面をAIに食わせてBFS弱いなーという確認をしたりしていた．</p>

<p>その後は#w8hackの打ち上げでピザ食べて，自分は特に進展なく1日が終わる．
この時点で@eagletmtの探索が結構良い感じだったので，今後はこのAIを改良すれば良いんじゃないかという感じになってくる．
あとλを塊でクラスタリングして巡るようにするといいんじゃないか，とかフィールドの更新は直前に変化したとこの8近傍だけ見れば十分だから高速化できるんじゃないか，とかそれHaskellだと遅延評価で高効率にできるよ！みたいな話をしていた．
Lightning Roundは@eagletmtの反復深化探索を投げた．</p>

<h3 id="section-2">3日目</h3>

<p>朝起きたらTrampolineとBeard and Razorなるものが追加されてた．
Trampolineはワープゾーン，BeardとRazorは増える壁とこの壁を消すアイテム．
どうもNested
Functionの実装にTrampoline使ってたり，関数型言語の偉い人がヒゲの人だったりするらしい．
ギャグなんだろうけど元ネタがわからないのでアレ．
仕様書からリンクの張ってある
<a href="http://www.youtube.com/watch?v=EFpwgXCwMNQ">トランポリン動画</a>
が大変シュールだった．</p>

<p>不確定要素が一気に増えたことで単なる探索ゲーの様相を呈してきて，クラスタリングとはなんだったのか……という感じになってめげそうになりつつ大学に向かう電車の中でTrampolineを実装．
大学に着いてからBeardとRazorの実装を開始するも，Beardが伸びる場所に岩が落ちてくるとどうなるのかという問題が……．
仕方ないのでまたWeb Validatorにいろいろ食わせて仕様を解析する．</p>

<p>このへんで@wand125が自動生成した迷路面やnethackみたいなダンジョン面をコミットしたり，@draftcodeがタイムアウトを計りながらAIを動かす評価用スクリプトを作ったりした．
CoffeeScriptで生成された面をPythonがC++に食わせて出力をRubyが検証，採点というよく分からない環境が出来上がる．</p>

<p>BeardとRazorの実装が終わったところで集中力が切れたので晩飯食べて，広いマップ用に幅優先探索で直近のλを取りに行くコードを書く．
とりあえず岩の近傍のうち下方3マスに入らなければ死ぬ可能性は低いだろう，と見てそこを避けるような経路でλが取れるなら取りに行くようにしたら案外うまく行った．</p>

<p>この実装が終わってしばらくして，新しい仕様追加のメールが来た． Higher
Order Rockなる，落とすとλになる岩が見つかったらしい．なんだそれ．
落とすとλになるくせにロボットに当たると死ぬとか微妙に面倒くさい仕様で，エンバグしながらシミュレータを書く．</p>

<p>その後はやることが尽きたので，@draftcode，@eagletmt，@choro3，@Mi_Sawa，ymzkらが探索方法の議論してるのを見ながらシミュレーションの高速化を図っていた．
前日に話してた通り，マップの中で変化が起きるのは直前に変化したマスの8近傍だけなので，更新はマップ全体をなめなくても一部だけ見れば良い．
ただ，実装したらどうも元より遅くなっている． 眠かったし諦めて帰宅．</p>

<h3 id="section-3">4日目</h3>

<p>9時に起きるつもりが気付いたら10時半だった．</p>

<p>海の日も東工大は授業があるらしく，ゼミ室が使えないという話だったのでwand家でコード書く．
8近傍更新のコードをよく見たらバグっていたので，直したらかなり速くなった．</p>

<p>夕方になって，実はゼミがなくゼミ室が空いてるという話を聞いたので大学へ．
サンプルを入れてテストしていたらC++コードもRubyコードもシミュレータが怪しげな挙動をしていたので，いくつかのバグを直す．
そんなことしていたら21時が近くなったのでtgzに固めて提出．
とりあえずREADMEにアルゴリズムの説明でも書くか，となったところで前日に書いた幅優先探索を入れてないことに気づく(元はRubyで書いてたのを提出用のC++コードに移植し忘れてた)．</p>

<p>お疲れ様でした．</p>
 
    
        <div id="kogarasi-program-icfpc2012" class="kogarasi-mark">ここにはかつてコメントが表示されていました</div>
    
  </div>
</div>
<div id="footer">
  <p>Last update: 2013-10-17 02:38:57</p>
</div>

</body>
</html>
